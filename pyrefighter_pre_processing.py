# -*- coding: utf-8 -*-
"""PyreFighter - Pre-processing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eWRc1nPXWcSi3a8AOrrxRggDH3WVU49M
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import datetime as dt
import statsmodels.api

df1 = pd.read_csv(r'LFB+Incident+data+from+January+2017.csv', sep = ';')
df2 = pd.read_csv(r'LFB+Mobilisation+data+from+January+2017.csv', sep = ';')
df3 = pd.read_csv(r'CoordoneesFireStations.csv')

df = df2.merge(df1, on = 'IncidentNumber')
df = df3.merge(df, on = 'DeployedFromStation_Name', suffixes=['', '_'])
df = df[['IncidentNumber', 'CalYear', 'IncidentGroup','PropertyCategory', 'AddressQualifier', 'IncGeo_BoroughName', 
         'Easting_rounded', 'Northing_rounded', 'IncidentStationGround', 'FirstPumpArriving_DeployedFromStation',
         'DateAndTimeMobilised', 'DateAndTimeMobile','DateAndTimeArrived', 'DeployedFromStation_Name','DeployedFromLocation', 
         'PumpOrder', 'DelayCode_Description','Latitude', 'Longitude']]

df.head()

#  Création de la variable cible 'ResponseTimeMinute'
df['DateAndTimeMobilised'] = pd.to_datetime(df['DateAndTimeMobilised'])
df['DateAndTimeArrived'] = pd.to_datetime(df['DateAndTimeArrived'])
df['ResponseTimeMinute'] = (df['DateAndTimeArrived'] - df['DateAndTimeMobilised']).dt.total_seconds()/60
# df.head()

# Nettoyage de la variable cible

# On cherche les temps de réponse négatifs
# df_new = df[df['ResponseTimeMinute'] < 0] # Il y a 128 incidents concernés (0.02 % des données)

# On cherche les temps de réponse aberrants Ex : ici supérieurs à 1h (60 min)
# df_new = df[df['ResponseTimeMinute'] > 60] # Il y a 679 incidents concernés (0.11 % des données)

# On supprime les incidents pour lesquels le temps de réponse est négatif ou supérieur à 1h (60 min)
df = df[(df['ResponseTimeMinute'] > 0) & (df['ResponseTimeMinute'] < 60)]
# df.info()
# df['ResponseTimeMinute'].describe()

# Création des variables 'HourMobilised', 'WeekdayMobilised', 'MonthMobilised'
df['HourMobilised'] = pd.to_datetime(df['DateAndTimeMobilised']).dt.hour
df['WeekdayMobilised'] = pd.to_datetime(df['DateAndTimeMobilised']).dt.weekday
df['MonthMobilised'] = pd.to_datetime(df['DateAndTimeMobilised']).dt.month

# Création de la variable 'Time_preparation'
df['DateAndTimeMobile'] = pd.to_datetime(df['DateAndTimeMobile'])
df["Time_Mobilised"] = pd.to_datetime(df["DateAndTimeMobilised"])
df["Time_preparation"] = (df['DateAndTimeMobile'] - df['DateAndTimeMobilised']).dt.total_seconds()/60

# df.head()

# Création de la variable 'CityCenter'
CityCenter = ['ISLINGTON', 'WESTMINSTER', 'HARINGEY', 'SOUTHWARK', 'TOWER HAMLETS', 'HACKNEY', 'NEWHAM', 'LAMBETH', 'CAMDEN',
               'WANDSWORTH', 'LEWISHAM', 'CITY OF LONDON', 'KENSINGTON AND CHELSEA', 'HAMMERSMITH AND FULHAM']

Peripherie = ['GREENWICH', 'BARKING AND DAGENHAM', 'EALING', 'BRENT', 'REDBRIDGE', 'CROYDON', 'HARROW', 'ENFIELD', 'BROMLEY',
              'BEXLEY', 'HAVERING', 'MERTON', 'HOUNSLOW', 'BARNET', 'HILLINGDON', 'SUTTON', 'WALTHAM FOREST', 
              'KINGSTON UPON THAMES', 'RICHMOND UPON THAMES']

df['CityCenter'] = df['IncGeo_BoroughName'].apply(lambda x: x in CityCenter)

# df.head()

# On recherche les données manquantes
df.isna().sum()

# La variable DelayCode_Description doit être supprimée car comporte trop de données manquantes.
df = df.drop('DelayCode_Description', axis = 1)

# On supprime les quelques données manquantes restantes
df = df.dropna(axis = 0, how = 'any')
df.isna().sum()

# On exporte notre DataFrame au format csv
df.to_csv('Preprocessing.csv',sep=';', index = False)

